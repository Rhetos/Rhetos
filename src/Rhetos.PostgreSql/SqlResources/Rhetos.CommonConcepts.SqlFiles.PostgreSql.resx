<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="TestAppDirectPostgreSql/DslScriptsCommonConcepts/SQL/AutoCodeCacheGetNext body.sql" xml:space="preserve">
    <value>IF grouping IS NULL SET grouping = '';

IF quantity &lt; 1
	BEGIN RAISERROR('Invalid argument: quantity (%d). The value must be 1 or greater. ', 16, 10, quantity); RETURN 1; END

DECLARE newCode INT;

UPDATE
	Common.AutoCodeCache acc WITH (ROWLOCK, UPDLOCK, SERIALIZABLE, INDEX(IX_AutoCodeCache_Entity_Property_Grouping_Prefix))
SET
	minDigits = MinDigits = CASE WHEN minDigits &gt; acc.MinDigits THEN minDigits ELSE acc.MinDigits END,
	newCode = LastCode = acc.LastCode + quantity
WHERE
	acc.Entity = entity
	AND acc.Property = property
	AND acc.Grouping = grouping
	AND acc.Prefix = prefix;

IF @ROWCOUNT = 0
BEGIN
	SET minDigits = ISNULL(minDigits, 0);
	SET newCode = quantity;

	INSERT INTO
		Common.AutoCodeCache WITH (ROWLOCK, UPDLOCK)
		(ID, Entity, Property, Grouping, Prefix, MinDigits, LastCode)
	VALUES
		(gen_random_uuid(), entity, property, grouping, prefix, minDigits, newCode);
END

SELECT MinDigits = minDigits, NewCode = newCode;</value>
  </data>
  <data name="TestAppDirectPostgreSql/DslScriptsCommonConcepts/SQL/AutoCodeCacheGetNext param.sql" xml:space="preserve">
    <value>entity varchar(256),
property varchar(256),
grouping varchar(256),
prefix varchar(256),
minDigits INT,
quantity INT -- Number of generated codes (i.e., the number of inserted items). Must be 1 or greater. For quantity greater than 1, newCode will contain the last generated codes. The generated codes are from newCode-quantity+1 to newCode.</value>
  </data>
  <data name="TestAppDirectPostgreSql/DslScriptsCommonConcepts/SQL/AutoCodeCacheUpdate body.sql" xml:space="preserve">
    <value>IF grouping IS NULL SET grouping = '';

UPDATE
	Common.AutoCodeCache acc WITH (ROWLOCK, UPDLOCK, INDEX(IX_AutoCodeCache_Entity_Property_Grouping_Prefix))
SET
	MinDigits = CASE WHEN providedCode &gt; acc.LastCode THEN minDigits ELSE acc.MinDigits END,
	LastCode = CASE WHEN providedCode &gt; acc.LastCode THEN providedCode ELSE acc.LastCode END
WHERE
	acc.Entity = entity
	AND acc.Property = property
	AND acc.Grouping = grouping
	AND acc.Prefix = prefix;

IF @ROWCOUNT = 0
BEGIN
	INSERT INTO
		Common.AutoCodeCache WITH (ROWLOCK, UPDLOCK)
		(ID, Entity, Property, Grouping, Prefix, MinDigits, LastCode)
	VALUES
		(gen_random_uuid(), entity, property, grouping, prefix, minDigits, providedCode);
END</value>
  </data>
  <data name="TestAppDirectPostgreSql/DslScriptsCommonConcepts/SQL/AutoCodeCacheUpdate param.sql" xml:space="preserve">
    <value>entity varchar(256),
property varchar(256),
grouping varchar(256),
prefix varchar(256),
minDigits INT,
providedCode INT -- Update the existing cache with the new code value, explicitly provided instead of generated. Either quantity or providedCode must be set.</value>
  </data>
  <data name="TestAppDirectPostgreSql/DslScriptsCommonConcepts/SQL/Log.ContextInfo default.sql" xml:space="preserve">
    <value>SELECT current_setting('rhetos.userinfo')</value>
  </data>
  <data name="TestAppDirectPostgreSql/DslScriptsCommonConcepts/SQL/Log.Created default.sql" xml:space="preserve">
    <value>LOCALTIMESTAMP(3)</value>
  </data>
  <data name="TestAppDirectPostgreSql/DslScriptsCommonConcepts/SQL/Log.UserName default.sql" xml:space="preserve">
    <value>current_user</value>
  </data>
  <data name="TestAppDirectPostgreSql/DslScriptsCommonConcepts/SQL/Log.Workstation default.sql" xml:space="preserve">
    <value>CONCAT_WS(':', inet_client_addr(), inet_client_port())</value>
  </data>
  <data name="TestAppDirectPostgreSql/DslScriptsCommonConcepts/SQL/LogReader.sql" xml:space="preserve">
    <value>SELECT
    ID,
    Created,
    UserName,
    Workstation,
    ContextInfo,
    Action,
    TableName,
    ItemId,
    Description
FROM
    Common.Log FOR KEY SHARE SKIP LOCKED

/*Common.LogReader AdditionalSource*/
</value>
  </data>
  <data name="TestAppDirectPostgreSql/DslScriptsCommonConcepts/SQL/LogRelatedItemReader.sql" xml:space="preserve">
    <value>SELECT
    ID,
    LogID,
    TableName,
    ItemId,
    Relation
FROM
    Common.LogRelatedItem FOR KEY SHARE SKIP LOCKED

/*Common.LogRelatedItemReader AdditionalSource*/</value>
  </data>
  <data name="TestAppDirectPostgreSql/DslScriptsCommonConcepts/SQL/RelatedEvents.sql" xml:space="preserve">
    <value>SELECT
    lri.ID AS ID,
    l.Created AS Created,
    l.UserName AS UserName,
    l.Workstation AS Workstation,
    l.ContextInfo AS ContextInfo,
    l.Action AS Action,
    l.TableName AS TableName,
    l.ItemId AS ItemId,
    l.Description AS Description,
    l.ID AS LogID,
    lri.Relation,
    lri.TableName AS RelatedToTable,
    lri.ItemId AS RelatedToItem
FROM
    Common.LogRelatedItemReader lri
    INNER JOIN Common.LogReader l ON l.ID = lri.LogID

UNION ALL

SELECT
    l.ID AS ID,
    l.Created AS Created,
    l.UserName AS UserName,
    l.Workstation AS Workstation,
    l.ContextInfo AS ContextInfo,
    l.Action AS Action,
    l.TableName AS TableName,
    l.ItemId AS ItemId,
    l.Description AS Description,
    l.ID AS LogID,
    '' AS Relation,
    l.TableName AS RelatedToTable,
    l.ItemId AS RelatedToItem
FROM
    Common.LogReader l</value>
  </data>
</root>